!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BASIC_CI_SIZE	./src/lstate.h	32;"	d
BASIC_STACK_SIZE	./src/lstate.h	34;"	d
BITRK	./src/lopcodes.h	119;"	d
BLACKBIT	./src/lgc.h	56;"	d
BinOpr	./src/lcode.h	/^typedef enum BinOpr {$/;"	g
BinOpr	./src/lcode.h	/^} BinOpr;$/;"	t	typeref:enum:BinOpr
CClosure	./src/lobject.h	/^typedef struct CClosure {$/;"	s
CClosure	./src/lobject.h	/^} CClosure;$/;"	t	typeref:struct:CClosure
CREATE_ABC	./src/lopcodes.h	104;"	d
CREATE_ABx	./src/lopcodes.h	109;"	d
CallInfo	./src/lstate.h	/^typedef struct CallInfo {$/;"	s
CallInfo	./src/lstate.h	/^} CallInfo;$/;"	t	typeref:struct:CallInfo
Closure	./src/lobject.h	/^typedef union Closure {$/;"	u
Closure	./src/lobject.h	/^} Closure;$/;"	t	typeref:union:Closure
ClosureHeader	./src/lobject.h	/^  ClosureHeader;$/;"	m	struct:CClosure
ClosureHeader	./src/lobject.h	/^  ClosureHeader;$/;"	m	struct:LClosure
ClosureHeader	./src/lobject.h	291;"	d
CommonHeader	./src/lobject.h	/^    CommonHeader;$/;"	m	struct:TString::__anon6
CommonHeader	./src/lobject.h	/^    CommonHeader;$/;"	m	struct:Udata::__anon7
CommonHeader	./src/lobject.h	/^  CommonHeader;$/;"	m	struct:GCheader
CommonHeader	./src/lobject.h	/^  CommonHeader;$/;"	m	struct:Proto
CommonHeader	./src/lobject.h	/^  CommonHeader;$/;"	m	struct:Table
CommonHeader	./src/lobject.h	/^  CommonHeader;$/;"	m	struct:UpVal
CommonHeader	./src/lobject.h	43;"	d
CommonHeader	./src/lstate.h	/^  CommonHeader;$/;"	m	struct:lua_State
EOZ	./src/lzio.h	16;"	d
EXTRA_STACK	./src/lstate.h	29;"	d
FINALIZEDBIT	./src/lgc.h	57;"	d
FIRST_RESERVED	./src/llex.h	14;"	d
FIXEDBIT	./src/lgc.h	60;"	d
FuncState	./src/lparser.h	/^typedef struct FuncState {$/;"	s
FuncState	./src/lparser.h	/^} FuncState;$/;"	t	typeref:struct:FuncState
G	./src/lstate.h	130;"	d
GCObject	./src/lobject.h	/^typedef union GCObject GCObject;$/;"	t	typeref:union:GCObject
GCObject	./src/lstate.h	/^union GCObject {$/;"	u
GCSfinalize	./src/lgc.h	21;"	d
GCSpause	./src/lgc.h	17;"	d
GCSpropagate	./src/lgc.h	18;"	d
GCSsweep	./src/lgc.h	20;"	d
GCSsweepstring	./src/lgc.h	19;"	d
GCheader	./src/lobject.h	/^typedef struct GCheader {$/;"	s
GCheader	./src/lobject.h	/^} GCheader;$/;"	t	typeref:struct:GCheader
GCthreshold	./src/lstate.h	/^  lu_mem GCthreshold;$/;"	m	struct:global_State
GETARG_A	./src/lopcodes.h	84;"	d
GETARG_B	./src/lopcodes.h	88;"	d
GETARG_Bx	./src/lopcodes.h	96;"	d
GETARG_C	./src/lopcodes.h	92;"	d
GETARG_sBx	./src/lopcodes.h	100;"	d
GET_OPCODE	./src/lopcodes.h	80;"	d
INDEXK	./src/lopcodes.h	125;"	d
ISK	./src/lopcodes.h	122;"	d
Instruction	./src/llimits.h	/^typedef lu_int32 Instruction;$/;"	t
IntPoint	./src/llimits.h	42;"	d
KEYWEAKBIT	./src/lgc.h	58;"	d
L	./src/lauxlib.h	/^  lua_State *L;$/;"	m	struct:luaL_Buffer
L	./src/llex.h	/^  struct lua_State *L;$/;"	m	struct:LexState	typeref:struct:LexState::lua_State
L	./src/lparser.h	/^  struct lua_State *L;  \/* copy of the Lua state *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::lua_State
L	./src/lzio.h	/^  lua_State *L;			\/* Lua state (for reader) *\/$/;"	m	struct:Zio
LAST_TAG	./src/lobject.h	20;"	d
LClosure	./src/lobject.h	/^typedef struct LClosure {$/;"	s
LClosure	./src/lobject.h	/^} LClosure;$/;"	t	typeref:struct:LClosure
LFIELDS_PER_FLUSH	./src/lopcodes.h	265;"	d
LUAC_FORMAT	./src/lundump.h	31;"	d
LUAC_HEADERSIZE	./src/lundump.h	34;"	d
LUAC_VERSION	./src/lundump.h	28;"	d
LUA_AUTHORS	./src/lua.h	23;"	d
LUA_COLIBNAME	./src/lualib.h	18;"	d
LUA_COPYRIGHT	./src/lua.h	22;"	d
LUA_DBLIBNAME	./src/lualib.h	36;"	d
LUA_ENVIRONINDEX	./src/lua.h	37;"	d
LUA_ERRERR	./src/lua.h	47;"	d
LUA_ERRFILE	./src/lauxlib.h	32;"	d
LUA_ERRMEM	./src/lua.h	46;"	d
LUA_ERRRUN	./src/lua.h	44;"	d
LUA_ERRSYNTAX	./src/lua.h	45;"	d
LUA_FILEHANDLE	./src/lualib.h	15;"	d
LUA_GCCOLLECT	./src/lua.h	223;"	d
LUA_GCCOUNT	./src/lua.h	224;"	d
LUA_GCCOUNTB	./src/lua.h	225;"	d
LUA_GCRESTART	./src/lua.h	222;"	d
LUA_GCSETPAUSE	./src/lua.h	227;"	d
LUA_GCSETSTEPMUL	./src/lua.h	228;"	d
LUA_GCSTEP	./src/lua.h	226;"	d
LUA_GCSTOP	./src/lua.h	221;"	d
LUA_GLOBALSINDEX	./src/lua.h	38;"	d
LUA_HOOKCALL	./src/lua.h	311;"	d
LUA_HOOKCOUNT	./src/lua.h	314;"	d
LUA_HOOKLINE	./src/lua.h	313;"	d
LUA_HOOKRET	./src/lua.h	312;"	d
LUA_HOOKTAILRET	./src/lua.h	315;"	d
LUA_IOLIBNAME	./src/lualib.h	24;"	d
LUA_LOADLIBNAME	./src/lualib.h	39;"	d
LUA_MASKCALL	./src/lua.h	321;"	d
LUA_MASKCOUNT	./src/lua.h	324;"	d
LUA_MASKLINE	./src/lua.h	323;"	d
LUA_MASKRET	./src/lua.h	322;"	d
LUA_MATHLIBNAME	./src/lualib.h	33;"	d
LUA_MINBUFFER	./src/llimits.h	105;"	d
LUA_MINSTACK	./src/lua.h	87;"	d
LUA_MULTRET	./src/lua.h	30;"	d
LUA_NOREF	./src/lauxlib.h	159;"	d
LUA_OSLIBNAME	./src/lualib.h	27;"	d
LUA_REFNIL	./src/lauxlib.h	160;"	d
LUA_REGISTRYINDEX	./src/lua.h	36;"	d
LUA_RELEASE	./src/lua.h	20;"	d
LUA_SIGNATURE	./src/lua.h	27;"	d
LUA_STRLIBNAME	./src/lualib.h	30;"	d
LUA_TABLIBNAME	./src/lualib.h	21;"	d
LUA_TBOOLEAN	./src/lua.h	75;"	d
LUA_TDEADKEY	./src/lobject.h	30;"	d
LUA_TFUNCTION	./src/lua.h	80;"	d
LUA_TLIGHTUSERDATA	./src/lua.h	76;"	d
LUA_TNIL	./src/lua.h	74;"	d
LUA_TNONE	./src/lua.h	72;"	d
LUA_TNUMBER	./src/lua.h	77;"	d
LUA_TPROTO	./src/lobject.h	28;"	d
LUA_TSTRING	./src/lua.h	78;"	d
LUA_TTABLE	./src/lua.h	79;"	d
LUA_TTHREAD	./src/lua.h	82;"	d
LUA_TUPVAL	./src/lobject.h	29;"	d
LUA_TUSERDATA	./src/lua.h	81;"	d
LUA_VERSION	./src/lua.h	19;"	d
LUA_VERSION_NUM	./src/lua.h	21;"	d
LUA_YIELD	./src/lua.h	43;"	d
L_Umaxalign	./src/llimits.h	/^typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;$/;"	t
LexState	./src/llex.h	/^typedef struct LexState {$/;"	s
LexState	./src/llex.h	/^} LexState;$/;"	t	typeref:struct:LexState
LocVar	./src/lobject.h	/^typedef struct LocVar {$/;"	s
LocVar	./src/lobject.h	/^} LocVar;$/;"	t	typeref:struct:LocVar
MASK0	./src/lopcodes.h	74;"	d
MASK1	./src/lopcodes.h	71;"	d
MAXARG_A	./src/lopcodes.h	65;"	d
MAXARG_B	./src/lopcodes.h	66;"	d
MAXARG_Bx	./src/lopcodes.h	57;"	d
MAXARG_Bx	./src/lopcodes.h	60;"	d
MAXARG_C	./src/lopcodes.h	67;"	d
MAXARG_sBx	./src/lopcodes.h	58;"	d
MAXARG_sBx	./src/lopcodes.h	61;"	d
MAXINDEXRK	./src/lopcodes.h	127;"	d
MAXSTACK	./src/llimits.h	93;"	d
MAX_INT	./src/llimits.h	35;"	d
MAX_LUMEM	./src/llimits.h	32;"	d
MAX_SIZET	./src/llimits.h	30;"	d
MEMERRMSG	./src/lmem.h	16;"	d
MINSTRTABSIZE	./src/llimits.h	99;"	d
Mbuffer	./src/lzio.h	/^typedef struct Mbuffer {$/;"	s
Mbuffer	./src/lzio.h	/^} Mbuffer;$/;"	t	typeref:struct:Mbuffer
NO_JUMP	./src/lcode.h	20;"	d
NO_REG	./src/lopcodes.h	136;"	d
NUM_OPCODES	./src/lopcodes.h	211;"	d
NUM_RESERVED	./src/llex.h	36;"	d
NUM_TAGS	./src/lobject.h	22;"	d
Node	./src/lobject.h	/^typedef struct Node {$/;"	s
Node	./src/lobject.h	/^} Node;$/;"	t	typeref:struct:Node
OPR_ADD	./src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_AND	./src/lcode.h	/^  OPR_AND, OPR_OR,$/;"	e	enum:BinOpr
OPR_CONCAT	./src/lcode.h	/^  OPR_CONCAT,$/;"	e	enum:BinOpr
OPR_DIV	./src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_EQ	./src/lcode.h	/^  OPR_NE, OPR_EQ,$/;"	e	enum:BinOpr
OPR_GE	./src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_GT	./src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_LE	./src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_LEN	./src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_LT	./src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_MINUS	./src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_MOD	./src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_MUL	./src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_NE	./src/lcode.h	/^  OPR_NE, OPR_EQ,$/;"	e	enum:BinOpr
OPR_NOBINOPR	./src/lcode.h	/^  OPR_NOBINOPR$/;"	e	enum:BinOpr
OPR_NOT	./src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_NOUNOPR	./src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_OR	./src/lcode.h	/^  OPR_AND, OPR_OR,$/;"	e	enum:BinOpr
OPR_POW	./src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_SUB	./src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OP_ADD	./src/lopcodes.h	/^OP_ADD,\/*	A B C	R(A) := RK(B) + RK(C)				*\/$/;"	e	enum:__anon12
OP_CALL	./src/lopcodes.h	/^OP_CALL,\/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) *\/$/;"	e	enum:__anon12
OP_CLOSE	./src/lopcodes.h	/^OP_CLOSE,\/*	A 	close all variables in the stack up to (>=) R(A)*\/$/;"	e	enum:__anon12
OP_CLOSURE	./src/lopcodes.h	/^OP_CLOSURE,\/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*\/$/;"	e	enum:__anon12
OP_CONCAT	./src/lopcodes.h	/^OP_CONCAT,\/*	A B C	R(A) := R(B).. ... ..R(C)			*\/$/;"	e	enum:__anon12
OP_DIV	./src/lopcodes.h	/^OP_DIV,\/*	A B C	R(A) := RK(B) \/ RK(C)				*\/$/;"	e	enum:__anon12
OP_EQ	./src/lopcodes.h	/^OP_EQ,\/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*\/$/;"	e	enum:__anon12
OP_FORLOOP	./src/lopcodes.h	/^OP_FORLOOP,\/*	A sBx	R(A)+=R(A+2);$/;"	e	enum:__anon12
OP_FORPREP	./src/lopcodes.h	/^OP_FORPREP,\/*	A sBx	R(A)-=R(A+2); pc+=sBx				*\/$/;"	e	enum:__anon12
OP_GETGLOBAL	./src/lopcodes.h	/^OP_GETGLOBAL,\/*	A Bx	R(A) := Gbl[Kst(Bx)]				*\/$/;"	e	enum:__anon12
OP_GETTABLE	./src/lopcodes.h	/^OP_GETTABLE,\/*	A B C	R(A) := R(B)[RK(C)]				*\/$/;"	e	enum:__anon12
OP_GETUPVAL	./src/lopcodes.h	/^OP_GETUPVAL,\/*	A B	R(A) := UpValue[B]				*\/$/;"	e	enum:__anon12
OP_JMP	./src/lopcodes.h	/^OP_JMP,\/*	sBx	pc+=sBx					*\/$/;"	e	enum:__anon12
OP_LE	./src/lopcodes.h	/^OP_LE,\/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++  		*\/$/;"	e	enum:__anon12
OP_LEN	./src/lopcodes.h	/^OP_LEN,\/*	A B	R(A) := length of R(B)				*\/$/;"	e	enum:__anon12
OP_LOADBOOL	./src/lopcodes.h	/^OP_LOADBOOL,\/*	A B C	R(A) := (Bool)B; if (C) pc++			*\/$/;"	e	enum:__anon12
OP_LOADK	./src/lopcodes.h	/^OP_LOADK,\/*	A Bx	R(A) := Kst(Bx)					*\/$/;"	e	enum:__anon12
OP_LOADNIL	./src/lopcodes.h	/^OP_LOADNIL,\/*	A B	R(A) := ... := R(B) := nil			*\/$/;"	e	enum:__anon12
OP_LT	./src/lopcodes.h	/^OP_LT,\/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*\/$/;"	e	enum:__anon12
OP_MOD	./src/lopcodes.h	/^OP_MOD,\/*	A B C	R(A) := RK(B) % RK(C)				*\/$/;"	e	enum:__anon12
OP_MOVE	./src/lopcodes.h	/^OP_MOVE,\/*	A B	R(A) := R(B)					*\/$/;"	e	enum:__anon12
OP_MUL	./src/lopcodes.h	/^OP_MUL,\/*	A B C	R(A) := RK(B) * RK(C)				*\/$/;"	e	enum:__anon12
OP_NEWTABLE	./src/lopcodes.h	/^OP_NEWTABLE,\/*	A B C	R(A) := {} (size = B,C)				*\/$/;"	e	enum:__anon12
OP_NOT	./src/lopcodes.h	/^OP_NOT,\/*	A B	R(A) := not R(B)				*\/$/;"	e	enum:__anon12
OP_POW	./src/lopcodes.h	/^OP_POW,\/*	A B C	R(A) := RK(B) ^ RK(C)				*\/$/;"	e	enum:__anon12
OP_RETURN	./src/lopcodes.h	/^OP_RETURN,\/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*\/$/;"	e	enum:__anon12
OP_SELF	./src/lopcodes.h	/^OP_SELF,\/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*\/$/;"	e	enum:__anon12
OP_SETGLOBAL	./src/lopcodes.h	/^OP_SETGLOBAL,\/*	A Bx	Gbl[Kst(Bx)] := R(A)				*\/$/;"	e	enum:__anon12
OP_SETLIST	./src/lopcodes.h	/^OP_SETLIST,\/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*\/$/;"	e	enum:__anon12
OP_SETTABLE	./src/lopcodes.h	/^OP_SETTABLE,\/*	A B C	R(A)[RK(B)] := RK(C)				*\/$/;"	e	enum:__anon12
OP_SETUPVAL	./src/lopcodes.h	/^OP_SETUPVAL,\/*	A B	UpValue[B] := R(A)				*\/$/;"	e	enum:__anon12
OP_SUB	./src/lopcodes.h	/^OP_SUB,\/*	A B C	R(A) := RK(B) - RK(C)				*\/$/;"	e	enum:__anon12
OP_TAILCALL	./src/lopcodes.h	/^OP_TAILCALL,\/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*\/$/;"	e	enum:__anon12
OP_TEST	./src/lopcodes.h	/^OP_TEST,\/*	A C	if not (R(A) <=> C) then pc++			*\/ $/;"	e	enum:__anon12
OP_TESTSET	./src/lopcodes.h	/^OP_TESTSET,\/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*\/ $/;"	e	enum:__anon12
OP_TFORLOOP	./src/lopcodes.h	/^OP_TFORLOOP,\/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); $/;"	e	enum:__anon12
OP_UNM	./src/lopcodes.h	/^OP_UNM,\/*	A B	R(A) := -R(B)					*\/$/;"	e	enum:__anon12
OP_VARARG	./src/lopcodes.h	/^OP_VARARG\/*	A B	R(A), R(A+1), ..., R(A+B-1) = vararg		*\/$/;"	e	enum:__anon12
OpArgK	./src/lopcodes.h	/^  OpArgK   \/* argument is a constant or register\/constant *\/$/;"	e	enum:OpArgMask
OpArgMask	./src/lopcodes.h	/^enum OpArgMask {$/;"	g
OpArgN	./src/lopcodes.h	/^  OpArgN,  \/* argument is not used *\/$/;"	e	enum:OpArgMask
OpArgR	./src/lopcodes.h	/^  OpArgR,  \/* argument is a register or a jump offset *\/$/;"	e	enum:OpArgMask
OpArgU	./src/lopcodes.h	/^  OpArgU,  \/* argument is used *\/$/;"	e	enum:OpArgMask
OpCode	./src/lopcodes.h	/^} OpCode;$/;"	t	typeref:enum:__anon12
OpMode	./src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	g
PCRC	./src/ldo.h	33;"	d
PCRLUA	./src/ldo.h	32;"	d
PCRYIELD	./src/ldo.h	34;"	d
POS_A	./src/lopcodes.h	45;"	d
POS_B	./src/lopcodes.h	47;"	d
POS_Bx	./src/lopcodes.h	48;"	d
POS_C	./src/lopcodes.h	46;"	d
POS_OP	./src/lopcodes.h	44;"	d
Pfunc	./src/ldo.h	/^typedef void (*Pfunc) (lua_State *L, void *ud);$/;"	t
Proto	./src/lobject.h	/^typedef struct Proto {$/;"	s
Proto	./src/lobject.h	/^} Proto;$/;"	t	typeref:struct:Proto
RESERVED	./src/llex.h	/^enum RESERVED {$/;"	g
RKASK	./src/lopcodes.h	130;"	d
SETARG_A	./src/lopcodes.h	85;"	d
SETARG_B	./src/lopcodes.h	89;"	d
SETARG_Bx	./src/lopcodes.h	97;"	d
SETARG_C	./src/lopcodes.h	93;"	d
SETARG_sBx	./src/lopcodes.h	101;"	d
SET_OPCODE	./src/lopcodes.h	81;"	d
SFIXEDBIT	./src/lgc.h	61;"	d
SIZE_A	./src/lopcodes.h	40;"	d
SIZE_B	./src/lopcodes.h	38;"	d
SIZE_Bx	./src/lopcodes.h	39;"	d
SIZE_C	./src/lopcodes.h	37;"	d
SIZE_OP	./src/lopcodes.h	42;"	d
SemInfo	./src/llex.h	/^} SemInfo;  \/* semantics information *\/$/;"	t	typeref:union:__anon1
StkId	./src/lobject.h	/^typedef TValue *StkId;  \/* index to stack elements *\/$/;"	t
TK_AND	./src/llex.h	/^  TK_AND = FIRST_RESERVED, TK_BREAK,$/;"	e	enum:RESERVED
TK_BREAK	./src/llex.h	/^  TK_AND = FIRST_RESERVED, TK_BREAK,$/;"	e	enum:RESERVED
TK_CONCAT	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_DO	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_DOTS	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_ELSE	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_ELSEIF	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_END	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_EOS	./src/llex.h	/^  TK_NAME, TK_STRING, TK_EOS$/;"	e	enum:RESERVED
TK_EQ	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_FALSE	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_FOR	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_FUNCTION	./src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_GE	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_IF	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_IN	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_LE	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_LOCAL	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_NAME	./src/llex.h	/^  TK_NAME, TK_STRING, TK_EOS$/;"	e	enum:RESERVED
TK_NE	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_NIL	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_NOT	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_NUMBER	./src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_OR	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_REPEAT	./src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_RETURN	./src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_STRING	./src/llex.h	/^  TK_NAME, TK_STRING, TK_EOS$/;"	e	enum:RESERVED
TK_THEN	./src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_TRUE	./src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_UNTIL	./src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_WHILE	./src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TKey	./src/lobject.h	/^typedef union TKey {$/;"	u
TKey	./src/lobject.h	/^} TKey;$/;"	t	typeref:union:TKey
TMS	./src/ltm.h	/^} TMS;$/;"	t	typeref:enum:__anon11
TM_ADD	./src/ltm.h	/^  TM_ADD,$/;"	e	enum:__anon11
TM_CALL	./src/ltm.h	/^  TM_CALL,$/;"	e	enum:__anon11
TM_CONCAT	./src/ltm.h	/^  TM_CONCAT,$/;"	e	enum:__anon11
TM_DIV	./src/ltm.h	/^  TM_DIV,$/;"	e	enum:__anon11
TM_EQ	./src/ltm.h	/^  TM_EQ,  \/* last tag method with `fast' access *\/$/;"	e	enum:__anon11
TM_GC	./src/ltm.h	/^  TM_GC,$/;"	e	enum:__anon11
TM_INDEX	./src/ltm.h	/^  TM_INDEX,$/;"	e	enum:__anon11
TM_LE	./src/ltm.h	/^  TM_LE,$/;"	e	enum:__anon11
TM_LEN	./src/ltm.h	/^  TM_LEN,$/;"	e	enum:__anon11
TM_LT	./src/ltm.h	/^  TM_LT,$/;"	e	enum:__anon11
TM_MOD	./src/ltm.h	/^  TM_MOD,$/;"	e	enum:__anon11
TM_MODE	./src/ltm.h	/^  TM_MODE,$/;"	e	enum:__anon11
TM_MUL	./src/ltm.h	/^  TM_MUL,$/;"	e	enum:__anon11
TM_N	./src/ltm.h	/^  TM_N		\/* number of elements in the enum *\/$/;"	e	enum:__anon11
TM_NEWINDEX	./src/ltm.h	/^  TM_NEWINDEX,$/;"	e	enum:__anon11
TM_POW	./src/ltm.h	/^  TM_POW,$/;"	e	enum:__anon11
TM_SUB	./src/ltm.h	/^  TM_SUB,$/;"	e	enum:__anon11
TM_UNM	./src/ltm.h	/^  TM_UNM,$/;"	e	enum:__anon11
TOKEN_LEN	./src/llex.h	17;"	d
TString	./src/lobject.h	/^typedef union TString {$/;"	u
TString	./src/lobject.h	/^} TString;$/;"	t	typeref:union:TString
TValue	./src/lobject.h	/^} TValue;$/;"	t	typeref:struct:lua_TValue
TValuefields	./src/lobject.h	/^    TValuefields;$/;"	m	struct:TKey::__anon10
TValuefields	./src/lobject.h	/^  TValuefields;$/;"	m	struct:lua_TValue
TValuefields	./src/lobject.h	71;"	d
Table	./src/lobject.h	/^typedef struct Table {$/;"	s
Table	./src/lobject.h	/^} Table;$/;"	t	typeref:struct:Table
Token	./src/llex.h	/^typedef struct Token {$/;"	s
Token	./src/llex.h	/^} Token;$/;"	t	typeref:struct:Token
UNUSED	./src/llimits.h	70;"	d
Udata	./src/lobject.h	/^typedef union Udata {$/;"	u
Udata	./src/lobject.h	/^} Udata;$/;"	t	typeref:union:Udata
UnOpr	./src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	g
UnOpr	./src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	t	typeref:enum:UnOpr
UpVal	./src/lobject.h	/^typedef struct UpVal {$/;"	s
UpVal	./src/lobject.h	/^} UpVal;$/;"	t	typeref:struct:UpVal
VALUEWEAKBIT	./src/lgc.h	59;"	d
VARARG_HASARG	./src/lobject.h	257;"	d
VARARG_ISVARARG	./src/lobject.h	258;"	d
VARARG_NEEDSARG	./src/lobject.h	259;"	d
VCALL	./src/lparser.h	/^  VCALL,	\/* info = instruction pc *\/$/;"	e	enum:__anon2
VFALSE	./src/lparser.h	/^  VFALSE,$/;"	e	enum:__anon2
VGLOBAL	./src/lparser.h	/^  VGLOBAL,	\/* info = index of table; aux = index of global name in `k' *\/$/;"	e	enum:__anon2
VINDEXED	./src/lparser.h	/^  VINDEXED,	\/* info = table register; aux = index register (or `k') *\/$/;"	e	enum:__anon2
VJMP	./src/lparser.h	/^  VJMP,		\/* info = instruction pc *\/$/;"	e	enum:__anon2
VK	./src/lparser.h	/^  VK,		\/* info = index of constant in `k' *\/$/;"	e	enum:__anon2
VKNUM	./src/lparser.h	/^  VKNUM,	\/* nval = numerical value *\/$/;"	e	enum:__anon2
VLOCAL	./src/lparser.h	/^  VLOCAL,	\/* info = local register *\/$/;"	e	enum:__anon2
VNIL	./src/lparser.h	/^  VNIL,$/;"	e	enum:__anon2
VNONRELOC	./src/lparser.h	/^  VNONRELOC,	\/* info = result register *\/$/;"	e	enum:__anon2
VRELOCABLE	./src/lparser.h	/^  VRELOCABLE,	\/* info = instruction pc *\/$/;"	e	enum:__anon2
VTRUE	./src/lparser.h	/^  VTRUE,$/;"	e	enum:__anon2
VUPVAL	./src/lparser.h	/^  VUPVAL,       \/* info = index of upvalue in `upvalues' *\/$/;"	e	enum:__anon2
VVARARG	./src/lparser.h	/^  VVARARG	\/* info = instruction pc *\/$/;"	e	enum:__anon2
VVOID	./src/lparser.h	/^  VVOID,	\/* no value *\/$/;"	e	enum:__anon2
Value	./src/lobject.h	/^} Value;$/;"	t	typeref:union:__anon5
WHITE0BIT	./src/lgc.h	54;"	d
WHITE1BIT	./src/lgc.h	55;"	d
WHITEBITS	./src/lgc.h	62;"	d
ZIO	./src/lzio.h	/^typedef struct Zio ZIO;$/;"	t	typeref:struct:Zio
Zio	./src/lzio.h	/^struct Zio {$/;"	s
actvar	./src/lparser.h	/^  unsigned short actvar[LUAI_MAXVARS];  \/* declared-variable stack *\/$/;"	m	struct:FuncState
allowhook	./src/lstate.h	/^  lu_byte allowhook;$/;"	m	struct:lua_State
api_check	./src/llimits.h	58;"	d
api_check	./src/llimits.h	64;"	d
array	./src/lobject.h	/^  TValue *array;  \/* array part *\/$/;"	m	struct:Table
aux	./src/lparser.h	/^    struct { int info, aux; } s;$/;"	m	struct:expdesc::__anon3::__anon4
b	./src/lobject.h	/^  int b;$/;"	m	union:__anon5
base	./src/lstate.h	/^  StkId base;  \/* base for this function *\/$/;"	m	struct:CallInfo
base	./src/lstate.h	/^  StkId base;  \/* base of current function *\/$/;"	m	struct:lua_State
baseCcalls	./src/lstate.h	/^  unsigned short baseCcalls;  \/* nested C calls when resuming coroutine *\/$/;"	m	struct:lua_State
base_ci	./src/lstate.h	/^  CallInfo *base_ci;  \/* array of CallInfo's *\/$/;"	m	struct:lua_State
basehookcount	./src/lstate.h	/^  int basehookcount;$/;"	m	struct:lua_State
bit2mask	./src/lgc.h	31;"	d
bitmask	./src/lgc.h	30;"	d
bl	./src/lparser.h	/^  struct BlockCnt *bl;  \/* chain of current blocks *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::BlockCnt
buff	./src/llex.h	/^  Mbuffer *buff;  \/* buffer for tokens *\/$/;"	m	struct:LexState
buff	./src/lstate.h	/^  Mbuffer buff;  \/* temporary buffer for string concatentation *\/$/;"	m	struct:global_State
buffer	./src/lauxlib.h	/^  char buffer[LUAL_BUFFERSIZE];$/;"	m	struct:luaL_Buffer
buffer	./src/lzio.h	/^  char *buffer;$/;"	m	struct:Mbuffer
buffsize	./src/lzio.h	/^  size_t buffsize;$/;"	m	struct:Mbuffer
bvalue	./src/lobject.h	100;"	d
c	./src/lobject.h	/^  CClosure c;$/;"	m	union:Closure
cast	./src/llimits.h	75;"	d
cast_byte	./src/llimits.h	78;"	d
cast_int	./src/llimits.h	80;"	d
cast_num	./src/llimits.h	79;"	d
ceillog2	./src/lobject.h	367;"	d
changewhite	./src/lgc.h	72;"	d
char2int	./src/lzio.h	20;"	d
check_exp	./src/llimits.h	57;"	d
check_exp	./src/llimits.h	63;"	d
checkconsistency	./src/lobject.h	108;"	d
checkliveness	./src/lobject.h	111;"	d
ci	./src/lstate.h	/^  CallInfo *ci;  \/* call info for current function *\/$/;"	m	struct:lua_State
ci_func	./src/lstate.h	60;"	d
cl	./src/lstate.h	/^  union Closure cl;$/;"	m	union:GCObject	typeref:union:GCObject::Closure
clvalue	./src/lobject.h	98;"	d
code	./src/lobject.h	/^  Instruction *code;$/;"	m	struct:Proto
condhardstacktests	./src/llimits.h	123;"	d
condhardstacktests	./src/llimits.h	125;"	d
curr_func	./src/lstate.h	59;"	d
current	./src/llex.h	/^  int current;  \/* current character (charint) *\/$/;"	m	struct:LexState
currentline	./src/lua.h	/^  int currentline;	\/* (l) *\/$/;"	m	struct:lua_Debug
currentwhite	./src/lstate.h	/^  lu_byte currentwhite;$/;"	m	struct:global_State
data	./src/lzio.h	/^  void* data;			\/* additional data *\/$/;"	m	struct:Zio
decpoint	./src/llex.h	/^  char decpoint;  \/* locale decimal point *\/$/;"	m	struct:LexState
dummy	./src/lobject.h	/^  L_Umaxalign dummy;  \/* ensures maximum alignment for `local' udata *\/$/;"	m	union:Udata
dummy	./src/lobject.h	/^  L_Umaxalign dummy;  \/* ensures maximum alignment for strings *\/$/;"	m	union:TString
end_ci	./src/lstate.h	/^  CallInfo *end_ci;  \/* points after end of ci array*\/$/;"	m	struct:lua_State
endpc	./src/lobject.h	/^  int endpc;    \/* first point where variable is dead *\/$/;"	m	struct:LocVar
env	./src/lobject.h	/^    struct Table *env;$/;"	m	struct:Udata::__anon7	typeref:struct:Udata::__anon7::Table
env	./src/lstate.h	/^  TValue env;  \/* temporary place for environments *\/$/;"	m	struct:lua_State
equalobj	./src/lvm.h	21;"	d
errfunc	./src/lstate.h	/^  ptrdiff_t errfunc;  \/* current error handling function (stack index) *\/$/;"	m	struct:lua_State
errorJmp	./src/lstate.h	/^  struct lua_longjmp *errorJmp;  \/* current error recover point *\/$/;"	m	struct:lua_State	typeref:struct:lua_State::lua_longjmp
estimate	./src/lstate.h	/^  lu_mem estimate;  \/* an estimate of number of bytes actually in use *\/$/;"	m	struct:global_State
event	./src/lua.h	/^  int event;$/;"	m	struct:lua_Debug
expdesc	./src/lparser.h	/^typedef struct expdesc {$/;"	s
expdesc	./src/lparser.h	/^} expdesc;$/;"	t	typeref:struct:expdesc
expkind	./src/lparser.h	/^} expkind;$/;"	t	typeref:enum:__anon2
f	./src/lobject.h	/^  lua_CFunction f;$/;"	m	struct:CClosure
f	./src/lparser.h	/^  Proto *f;  \/* current function header *\/$/;"	m	struct:FuncState
f	./src/lparser.h	/^  int f;  \/* patch list of `exit when false' *\/$/;"	m	struct:expdesc
f_isLua	./src/lstate.h	61;"	d
fasttm	./src/ltm.h	44;"	d
flags	./src/lobject.h	/^  lu_byte flags;  \/* 1<<p means tagmethod(p) is not present *\/ $/;"	m	struct:Table
frealloc	./src/lstate.h	/^  lua_Alloc frealloc;  \/* function to reallocate memory *\/$/;"	m	struct:global_State
freereg	./src/lparser.h	/^  int freereg;  \/* first free register *\/$/;"	m	struct:FuncState
fs	./src/llex.h	/^  struct FuncState *fs;  \/* `FuncState' is private to the parser *\/$/;"	m	struct:LexState	typeref:struct:LexState::FuncState
func	./src/lauxlib.h	/^  lua_CFunction func;$/;"	m	struct:luaL_Reg
func	./src/lstate.h	/^  StkId func;  \/* function index in the stack *\/$/;"	m	struct:CallInfo
gc	./src/lobject.h	/^  GCObject *gc;$/;"	m	union:__anon5
gcdept	./src/lstate.h	/^  lu_mem gcdept;  \/* how much GC is `behind schedule' *\/$/;"	m	struct:global_State
gch	./src/lstate.h	/^  GCheader gch;$/;"	m	union:GCObject
gclist	./src/lobject.h	/^  GCObject *gclist;$/;"	m	struct:Proto
gclist	./src/lobject.h	/^  GCObject *gclist;$/;"	m	struct:Table
gclist	./src/lstate.h	/^  GCObject *gclist;$/;"	m	struct:lua_State
gco2cl	./src/lstate.h	153;"	d
gco2h	./src/lstate.h	154;"	d
gco2p	./src/lstate.h	155;"	d
gco2th	./src/lstate.h	159;"	d
gco2ts	./src/lstate.h	150;"	d
gco2u	./src/lstate.h	152;"	d
gco2uv	./src/lstate.h	156;"	d
gcpause	./src/lstate.h	/^  int gcpause;  \/* size of pause between successive GCs *\/$/;"	m	struct:global_State
gcstate	./src/lstate.h	/^  lu_byte gcstate;  \/* state of garbage collector *\/$/;"	m	struct:global_State
gcstepmul	./src/lstate.h	/^  int gcstepmul;  \/* GC `granularity' *\/$/;"	m	struct:global_State
gcvalue	./src/lobject.h	91;"	d
getBMode	./src/lopcodes.h	255;"	d
getCMode	./src/lopcodes.h	256;"	d
getOpMode	./src/lopcodes.h	254;"	d
getcode	./src/lcode.h	39;"	d
getline	./src/ldebug.h	16;"	d
getstr	./src/lobject.h	210;"	d
gfasttm	./src/ltm.h	41;"	d
gkey	./src/ltable.h	14;"	d
global_State	./src/lstate.h	/^typedef struct global_State {$/;"	s
global_State	./src/lstate.h	/^} global_State;$/;"	t	typeref:struct:global_State
gnext	./src/ltable.h	16;"	d
gnode	./src/ltable.h	13;"	d
gray	./src/lstate.h	/^  GCObject *gray;  \/* list of gray objects *\/$/;"	m	struct:global_State
gray2black	./src/lgc.h	73;"	d
grayagain	./src/lstate.h	/^  GCObject *grayagain;  \/* list of objects to be traversed atomically *\/$/;"	m	struct:global_State
gt	./src/lstate.h	22;"	d
gval	./src/ltable.h	15;"	d
h	./src/lparser.h	/^  Table *h;  \/* table to find (and reuse) elements in `k' *\/$/;"	m	struct:FuncState
h	./src/lstate.h	/^  struct Table h;$/;"	m	union:GCObject	typeref:struct:GCObject::Table
hash	./src/lobject.h	/^    unsigned int hash;$/;"	m	struct:TString::__anon6
hash	./src/lstate.h	/^  GCObject **hash;$/;"	m	struct:stringtable
hook	./src/lstate.h	/^  lua_Hook hook;$/;"	m	struct:lua_State
hookcount	./src/lstate.h	/^  int hookcount;$/;"	m	struct:lua_State
hookmask	./src/lstate.h	/^  lu_byte hookmask;$/;"	m	struct:lua_State
hvalue	./src/lobject.h	99;"	d
iABC	./src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	e	enum:OpMode
iABx	./src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	e	enum:OpMode
iAsBx	./src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	e	enum:OpMode
i_ci	./src/lua.h	/^  int i_ci;  \/* active function *\/$/;"	m	struct:lua_Debug
i_key	./src/lobject.h	/^  TKey i_key;$/;"	m	struct:Node
i_val	./src/lobject.h	/^  TValue i_val;$/;"	m	struct:Node
incr_top	./src/ldo.h	22;"	d
info	./src/lparser.h	/^    struct { int info, aux; } s;$/;"	m	struct:expdesc::__anon3::__anon4
info	./src/lparser.h	/^  lu_byte info;$/;"	m	struct:upvaldesc
isLfunction	./src/lobject.h	316;"	d
isLua	./src/lstate.h	62;"	d
is_vararg	./src/lobject.h	/^  lu_byte is_vararg;$/;"	m	struct:Proto
isblack	./src/lgc.h	66;"	d
iscfunction	./src/lobject.h	315;"	d
iscollectable	./src/lobject.h	189;"	d
isdead	./src/lgc.h	70;"	d
isgray	./src/lgc.h	67;"	d
iswhite	./src/lgc.h	65;"	d
jpc	./src/lparser.h	/^  int jpc;  \/* list of pending jumps to `pc' *\/$/;"	m	struct:FuncState
k	./src/lobject.h	/^  TValue *k;  \/* constants used by the function *\/$/;"	m	struct:Proto
k	./src/lparser.h	/^  expkind k;$/;"	m	struct:expdesc
k	./src/lparser.h	/^  lu_byte k;$/;"	m	struct:upvaldesc
key2tval	./src/ltable.h	18;"	d
l	./src/lobject.h	/^    } l;$/;"	m	union:UpVal::__anon8	typeref:struct:UpVal::__anon8::__anon9
l	./src/lobject.h	/^  LClosure l;$/;"	m	union:Closure
l_G	./src/lstate.h	/^  global_State *l_G;$/;"	m	struct:lua_State
l_gt	./src/lstate.h	/^  TValue l_gt;  \/* table of globals *\/$/;"	m	struct:lua_State
l_isfalse	./src/lobject.h	103;"	d
l_mem	./src/llimits.h	/^typedef LUAI_MEM l_mem;$/;"	t
l_registry	./src/lstate.h	/^  TValue l_registry;$/;"	m	struct:global_State
l_setbit	./src/lgc.h	32;"	d
l_uacNumber	./src/llimits.h	/^typedef LUAI_UACNUMBER l_uacNumber;$/;"	t
lapi_h	./src/lapi.h	8;"	d
lastfree	./src/lobject.h	/^  Node *lastfree;  \/* any free position is before this position *\/$/;"	m	struct:Table
lastline	./src/llex.h	/^  int lastline;  \/* line of last token `consumed' *\/$/;"	m	struct:LexState
lastlinedefined	./src/lobject.h	/^  int lastlinedefined;$/;"	m	struct:Proto
lastlinedefined	./src/lua.h	/^  int lastlinedefined;	\/* (S) *\/$/;"	m	struct:lua_Debug
lasttarget	./src/lparser.h	/^  int lasttarget;   \/* `pc' of last `jump target' *\/$/;"	m	struct:FuncState
lauxlib_h	./src/lauxlib.h	9;"	d
lcode_h	./src/lcode.h	8;"	d
ldebug_h	./src/ldebug.h	8;"	d
ldo_h	./src/ldo.h	8;"	d
len	./src/lobject.h	/^    size_t len;$/;"	m	struct:TString::__anon6
len	./src/lobject.h	/^    size_t len;$/;"	m	struct:Udata::__anon7
lfunc_h	./src/lfunc.h	8;"	d
lgc_h	./src/lgc.h	8;"	d
linedefined	./src/lobject.h	/^  int linedefined;$/;"	m	struct:Proto
linedefined	./src/lua.h	/^  int linedefined;	\/* (S) *\/$/;"	m	struct:lua_Debug
lineinfo	./src/lobject.h	/^  int *lineinfo;  \/* map from opcodes to source lines *\/$/;"	m	struct:Proto
linenumber	./src/llex.h	/^  int linenumber;  \/* input line counter *\/$/;"	m	struct:LexState
llex_h	./src/llex.h	8;"	d
llimits_h	./src/llimits.h	8;"	d
lmem_h	./src/lmem.h	8;"	d
lmod	./src/lobject.h	355;"	d
lobject_h	./src/lobject.h	9;"	d
locvars	./src/lobject.h	/^  struct LocVar *locvars;  \/* information about local variables *\/$/;"	m	struct:Proto	typeref:struct:Proto::LocVar
lookahead	./src/llex.h	/^  Token lookahead;  \/* look ahead token *\/$/;"	m	struct:LexState
lopcodes_h	./src/lopcodes.h	8;"	d
lparser_h	./src/lparser.h	8;"	d
ls	./src/lparser.h	/^  struct LexState *ls;  \/* lexical state *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::LexState
lsizenode	./src/lobject.h	/^  lu_byte lsizenode;  \/* log2 of size of `node' array *\/$/;"	m	struct:Table
lstate_h	./src/lstate.h	8;"	d
lstring_h	./src/lstring.h	8;"	d
ltable_h	./src/ltable.h	8;"	d
ltm_h	./src/ltm.h	8;"	d
lu_byte	./src/llimits.h	/^typedef unsigned char lu_byte;$/;"	t
lu_int32	./src/llimits.h	/^typedef LUAI_UINT32 lu_int32;$/;"	t
lu_mem	./src/llimits.h	/^typedef LUAI_UMEM lu_mem;$/;"	t
luaC_barrier	./src/lgc.h	86;"	d
luaC_barriert	./src/lgc.h	89;"	d
luaC_checkGC	./src/lgc.h	80;"	d
luaC_objbarrier	./src/lgc.h	92;"	d
luaC_objbarriert	./src/lgc.h	96;"	d
luaC_white	./src/lgc.h	77;"	d
luaD_checkstack	./src/ldo.h	16;"	d
luaI_openlib	./src/lauxlib.h	27;"	d
luaK_codeAsBx	./src/lcode.h	41;"	d
luaK_setmultret	./src/lcode.h	43;"	d
luaL_Buffer	./src/lauxlib.h	/^typedef struct luaL_Buffer {$/;"	s
luaL_Buffer	./src/lauxlib.h	/^} luaL_Buffer;$/;"	t	typeref:struct:luaL_Buffer
luaL_Reg	./src/lauxlib.h	/^typedef struct luaL_Reg {$/;"	s
luaL_Reg	./src/lauxlib.h	/^} luaL_Reg;$/;"	t	typeref:struct:luaL_Reg
luaL_addchar	./src/lauxlib.h	136;"	d
luaL_addsize	./src/lauxlib.h	143;"	d
luaL_argcheck	./src/lauxlib.h	100;"	d
luaL_checkint	./src/lauxlib.h	104;"	d
luaL_checklong	./src/lauxlib.h	106;"	d
luaL_checkstring	./src/lauxlib.h	102;"	d
luaL_dofile	./src/lauxlib.h	111;"	d
luaL_dostring	./src/lauxlib.h	114;"	d
luaL_getmetatable	./src/lauxlib.h	117;"	d
luaL_getn	./src/lauxlib.h	22;"	d
luaL_opt	./src/lauxlib.h	119;"	d
luaL_optint	./src/lauxlib.h	105;"	d
luaL_optlong	./src/lauxlib.h	107;"	d
luaL_optstring	./src/lauxlib.h	103;"	d
luaL_putchar	./src/lauxlib.h	141;"	d
luaL_reg	./src/lauxlib.h	170;"	d
luaL_setn	./src/lauxlib.h	23;"	d
luaL_typename	./src/lauxlib.h	109;"	d
luaM_free	./src/lmem.h	25;"	d
luaM_freearray	./src/lmem.h	26;"	d
luaM_freemem	./src/lmem.h	24;"	d
luaM_growvector	./src/lmem.h	33;"	d
luaM_malloc	./src/lmem.h	28;"	d
luaM_new	./src/lmem.h	29;"	d
luaM_newvector	./src/lmem.h	30;"	d
luaM_reallocv	./src/lmem.h	19;"	d
luaM_reallocvector	./src/lmem.h	37;"	d
luaO_nilobject	./src/lobject.h	363;"	d
luaO_nilobject_	./src/lobject.h	/^LUAI_DATA const TValue luaO_nilobject_;$/;"	v
luaP_opmodes	./src/lopcodes.h	/^LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];$/;"	v
luaP_opnames	./src/lopcodes.h	/^LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];  \/* opcode names *\/$/;"	v
luaS_fix	./src/lstring.h	24;"	d
luaS_new	./src/lstring.h	20;"	d
luaS_newliteral	./src/lstring.h	21;"	d
luaT_typenames	./src/ltm.h	/^LUAI_DATA const char *const luaT_typenames[];$/;"	v
luaX_tokens	./src/llex.h	/^LUAI_DATA const char *const luaX_tokens [];$/;"	v
luaZ_buffer	./src/lzio.h	32;"	d
luaZ_bufflen	./src/lzio.h	34;"	d
luaZ_freebuffer	./src/lzio.h	43;"	d
luaZ_initbuffer	./src/lzio.h	30;"	d
luaZ_resetbuffer	./src/lzio.h	36;"	d
luaZ_resizebuffer	./src/lzio.h	39;"	d
luaZ_sizebuffer	./src/lzio.h	33;"	d
lua_Alloc	./src/lua.h	/^typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);$/;"	t
lua_CFunction	./src/lua.h	/^typedef int (*lua_CFunction) (lua_State *L);$/;"	t
lua_Chunkreader	./src/lua.h	293;"	d
lua_Chunkwriter	./src/lua.h	294;"	d
lua_Debug	./src/lua.h	/^struct lua_Debug {$/;"	s
lua_Debug	./src/lua.h	/^typedef struct lua_Debug lua_Debug;  \/* activation record *\/$/;"	t	typeref:struct:lua_Debug
lua_Hook	./src/lua.h	/^typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);$/;"	t
lua_Integer	./src/lua.h	/^typedef LUA_INTEGER lua_Integer;$/;"	t
lua_Number	./src/lua.h	/^typedef LUA_NUMBER lua_Number;$/;"	t
lua_Reader	./src/lua.h	/^typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);$/;"	t
lua_State	./src/lstate.h	/^struct lua_State {$/;"	s
lua_State	./src/lua.h	/^typedef struct lua_State lua_State;$/;"	t	typeref:struct:lua_State
lua_TValue	./src/lobject.h	/^typedef struct lua_TValue {$/;"	s
lua_Writer	./src/lua.h	/^typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);$/;"	t
lua_assert	./src/llimits.h	62;"	d
lua_assert	./src/lualib.h	49;"	d
lua_getgccount	./src/lua.h	291;"	d
lua_getglobal	./src/lua.h	277;"	d
lua_getref	./src/lauxlib.h	167;"	d
lua_getregistry	./src/lua.h	289;"	d
lua_h	./src/lua.h	10;"	d
lua_isboolean	./src/lua.h	268;"	d
lua_isfunction	./src/lua.h	264;"	d
lua_islightuserdata	./src/lua.h	266;"	d
lua_isnil	./src/lua.h	267;"	d
lua_isnone	./src/lua.h	270;"	d
lua_isnoneornil	./src/lua.h	271;"	d
lua_istable	./src/lua.h	265;"	d
lua_isthread	./src/lua.h	269;"	d
lua_lock	./src/llimits.h	110;"	d
lua_newtable	./src/lua.h	256;"	d
lua_open	./src/lua.h	287;"	d
lua_pop	./src/lua.h	254;"	d
lua_pushcfunction	./src/lua.h	260;"	d
lua_pushliteral	./src/lua.h	273;"	d
lua_ref	./src/lauxlib.h	162;"	d
lua_register	./src/lua.h	258;"	d
lua_setglobal	./src/lua.h	276;"	d
lua_strlen	./src/lua.h	262;"	d
lua_tostring	./src/lua.h	279;"	d
lua_unlock	./src/llimits.h	111;"	d
lua_unref	./src/lauxlib.h	165;"	d
lua_upvalueindex	./src/lua.h	39;"	d
luai_threadyield	./src/llimits.h	115;"	d
lualib_h	./src/lualib.h	9;"	d
lundump_h	./src/lundump.h	8;"	d
lvl	./src/lauxlib.h	/^  int lvl;  \/* number of strings in the stack (level) *\/$/;"	m	struct:luaL_Buffer
lvm_h	./src/lvm.h	8;"	d
lzio_h	./src/lzio.h	9;"	d
mainthread	./src/lstate.h	/^  struct lua_State *mainthread;$/;"	m	struct:global_State	typeref:struct:global_State::lua_State
maxstacksize	./src/lobject.h	/^  lu_byte maxstacksize;$/;"	m	struct:Proto
metatable	./src/lobject.h	/^    struct Table *metatable;$/;"	m	struct:Udata::__anon7	typeref:struct:Udata::__anon7::Table
metatable	./src/lobject.h	/^  struct Table *metatable;$/;"	m	struct:Table	typeref:struct:Table::Table
mt	./src/lstate.h	/^  struct Table *mt[NUM_TAGS];  \/* metatables for basic types *\/$/;"	m	struct:global_State	typeref:struct:global_State::Table
n	./src/lobject.h	/^  lua_Number n;$/;"	m	union:__anon5
n	./src/lzio.h	/^  size_t n;			\/* bytes still unread *\/$/;"	m	struct:Zio
n	./src/lzio.h	/^  size_t n;$/;"	m	struct:Mbuffer
nCcalls	./src/lstate.h	/^  unsigned short nCcalls;  \/* number of nested C calls *\/$/;"	m	struct:lua_State
nactvar	./src/lparser.h	/^  lu_byte nactvar;  \/* number of active local variables *\/$/;"	m	struct:FuncState
name	./src/lauxlib.h	/^  const char *name;$/;"	m	struct:luaL_Reg
name	./src/lua.h	/^  const char *name;	\/* (n) *\/$/;"	m	struct:lua_Debug
namewhat	./src/lua.h	/^  const char *namewhat;	\/* (n) `global', `local', `field', `method' *\/$/;"	m	struct:lua_Debug
next	./src/lobject.h	/^      struct UpVal *next;$/;"	m	struct:UpVal::__anon8::__anon9	typeref:struct:UpVal::__anon8::__anon9::UpVal
next	./src/lobject.h	/^    struct Node *next;  \/* for chaining *\/$/;"	m	struct:TKey::__anon10	typeref:struct:TKey::__anon10::Node
ngcotouv	./src/lstate.h	157;"	d
nk	./src/lobject.h	/^  } nk;$/;"	m	union:TKey	typeref:struct:TKey::__anon10
nk	./src/lparser.h	/^  int nk;  \/* number of elements in `k' *\/$/;"	m	struct:FuncState
nlocvars	./src/lparser.h	/^  short nlocvars;  \/* number of elements in `locvars' *\/$/;"	m	struct:FuncState
node	./src/lobject.h	/^  Node *node;$/;"	m	struct:Table
np	./src/lparser.h	/^  int np;  \/* number of elements in `p' *\/$/;"	m	struct:FuncState
nresults	./src/lstate.h	/^  int nresults;  \/* expected number of results from this function *\/$/;"	m	struct:CallInfo
numparams	./src/lobject.h	/^  lu_byte numparams;$/;"	m	struct:Proto
nups	./src/lobject.h	/^  lu_byte nups;  \/* number of upvalues *\/$/;"	m	struct:Proto
nups	./src/lua.h	/^  int nups;		\/* (u) number of upvalues *\/$/;"	m	struct:lua_Debug
nuse	./src/lstate.h	/^  lu_int32 nuse;  \/* number of elements *\/$/;"	m	struct:stringtable
nval	./src/lparser.h	/^    lua_Number nval;$/;"	m	union:expdesc::__anon3
nvalue	./src/lobject.h	93;"	d
obj2gco	./src/lstate.h	162;"	d
openupval	./src/lstate.h	/^  GCObject *openupval;  \/* list of open upvalues in this stack *\/$/;"	m	struct:lua_State
otherwhite	./src/lgc.h	69;"	d
p	./src/lauxlib.h	/^  char *p;			\/* current position in buffer *\/$/;"	m	struct:luaL_Buffer
p	./src/lobject.h	/^  struct Proto **p;  \/* functions defined inside the function *\/$/;"	m	struct:Proto	typeref:struct:Proto::Proto
p	./src/lobject.h	/^  struct Proto *p;$/;"	m	struct:LClosure	typeref:struct:LClosure::Proto
p	./src/lobject.h	/^  void *p;$/;"	m	union:__anon5
p	./src/lstate.h	/^  struct Proto p;$/;"	m	union:GCObject	typeref:struct:GCObject::Proto
p	./src/lzio.h	/^  const char *p;		\/* current position in buffer *\/$/;"	m	struct:Zio
panic	./src/lstate.h	/^  lua_CFunction panic;  \/* to be called in unprotected errors *\/$/;"	m	struct:global_State
pc	./src/lparser.h	/^  int pc;  \/* next position to code (equivalent to `ncode') *\/$/;"	m	struct:FuncState
pcRel	./src/ldebug.h	14;"	d
prev	./src/lobject.h	/^      struct UpVal *prev;$/;"	m	struct:UpVal::__anon8::__anon9	typeref:struct:UpVal::__anon8::__anon9::UpVal
prev	./src/lparser.h	/^  struct FuncState *prev;  \/* enclosing function *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::FuncState
pvalue	./src/lobject.h	92;"	d
r	./src/llex.h	/^  lua_Number r;$/;"	m	union:__anon1
rawgco2ts	./src/lstate.h	149;"	d
rawgco2u	./src/lstate.h	151;"	d
rawtsvalue	./src/lobject.h	94;"	d
rawuvalue	./src/lobject.h	96;"	d
reader	./src/lzio.h	/^  lua_Reader reader;$/;"	m	struct:Zio
registry	./src/lstate.h	25;"	d
reserved	./src/lobject.h	/^    lu_byte reserved;$/;"	m	struct:TString::__anon6
reset2bits	./src/lgc.h	36;"	d
resetbit	./src/lgc.h	33;"	d
resetbits	./src/lgc.h	27;"	d
resethookcount	./src/ldebug.h	18;"	d
restoreci	./src/ldo.h	28;"	d
restorestack	./src/ldo.h	25;"	d
rootgc	./src/lstate.h	/^  GCObject *rootgc;  \/* list of all collectable objects *\/$/;"	m	struct:global_State
s	./src/lparser.h	/^    struct { int info, aux; } s;$/;"	m	union:expdesc::__anon3	typeref:struct:expdesc::__anon3::__anon4
saveci	./src/ldo.h	27;"	d
savedpc	./src/lstate.h	/^  const Instruction *savedpc;  \/* `savedpc' of current function *\/$/;"	m	struct:lua_State
savedpc	./src/lstate.h	/^  const Instruction *savedpc;$/;"	m	struct:CallInfo
savestack	./src/ldo.h	24;"	d
seminfo	./src/llex.h	/^  SemInfo seminfo;$/;"	m	struct:Token
set2bits	./src/lgc.h	35;"	d
setbits	./src/lgc.h	28;"	d
setbvalue	./src/lobject.h	125;"	d
setclvalue	./src/lobject.h	143;"	d
sethvalue	./src/lobject.h	148;"	d
sethvalue2s	./src/lobject.h	176;"	d
setnilvalue	./src/lobject.h	117;"	d
setnvalue	./src/lobject.h	119;"	d
setobj	./src/lobject.h	161;"	d
setobj2n	./src/lobject.h	183;"	d
setobj2s	./src/lobject.h	174;"	d
setobj2t	./src/lobject.h	181;"	d
setobjs2s	./src/lobject.h	172;"	d
setobjt2t	./src/lobject.h	179;"	d
setptvalue	./src/lobject.h	153;"	d
setptvalue2s	./src/lobject.h	177;"	d
setpvalue	./src/lobject.h	122;"	d
setsvalue	./src/lobject.h	128;"	d
setsvalue2n	./src/lobject.h	184;"	d
setsvalue2s	./src/lobject.h	175;"	d
setthvalue	./src/lobject.h	138;"	d
setttype	./src/lobject.h	186;"	d
setuvalue	./src/lobject.h	133;"	d
short_src	./src/lua.h	/^  char short_src[LUA_IDSIZE]; \/* (S) *\/$/;"	m	struct:lua_Debug
size	./src/lstate.h	/^  int size;$/;"	m	struct:stringtable
sizeCclosure	./src/lfunc.h	14;"	d
sizeLclosure	./src/lfunc.h	17;"	d
size_ci	./src/lstate.h	/^  int size_ci;  \/* size of array `base_ci' *\/$/;"	m	struct:lua_State
sizearray	./src/lobject.h	/^  int sizearray;  \/* size of `array' array *\/$/;"	m	struct:Table
sizecode	./src/lobject.h	/^  int sizecode;$/;"	m	struct:Proto
sizek	./src/lobject.h	/^  int sizek;  \/* size of `k' *\/$/;"	m	struct:Proto
sizelineinfo	./src/lobject.h	/^  int sizelineinfo;$/;"	m	struct:Proto
sizelocvars	./src/lobject.h	/^  int sizelocvars;$/;"	m	struct:Proto
sizenode	./src/lobject.h	360;"	d
sizep	./src/lobject.h	/^  int sizep;  \/* size of `p' *\/$/;"	m	struct:Proto
sizestring	./src/lstring.h	16;"	d
sizeudata	./src/lstring.h	18;"	d
sizeupvalues	./src/lobject.h	/^  int sizeupvalues;$/;"	m	struct:Proto
source	./src/llex.h	/^  TString *source;  \/* current source name *\/$/;"	m	struct:LexState
source	./src/lobject.h	/^  TString  *source;$/;"	m	struct:Proto
source	./src/lua.h	/^  const char *source;	\/* (S) *\/$/;"	m	struct:lua_Debug
stack	./src/lstate.h	/^  StkId stack;  \/* stack base *\/$/;"	m	struct:lua_State
stack_last	./src/lstate.h	/^  StkId stack_last;  \/* last free slot in the stack *\/$/;"	m	struct:lua_State
stacksize	./src/lstate.h	/^  int stacksize;$/;"	m	struct:lua_State
startpc	./src/lobject.h	/^  int startpc;  \/* first point where variable is active *\/$/;"	m	struct:LocVar
status	./src/lstate.h	/^  lu_byte status;$/;"	m	struct:lua_State
stringtable	./src/lstate.h	/^typedef struct stringtable {$/;"	s
stringtable	./src/lstate.h	/^} stringtable;$/;"	t	typeref:struct:stringtable
strt	./src/lstate.h	/^  stringtable strt;  \/* hash table for strings *\/$/;"	m	struct:global_State
svalue	./src/lobject.h	211;"	d
sweepgc	./src/lstate.h	/^  GCObject **sweepgc;  \/* position of sweep in `rootgc' *\/$/;"	m	struct:global_State
sweepstrgc	./src/lstate.h	/^  int sweepstrgc;  \/* position of sweep in `strt' *\/$/;"	m	struct:global_State
t	./src/llex.h	/^  Token t;  \/* current token *\/$/;"	m	struct:LexState
t	./src/lparser.h	/^  int t;  \/* patch list of `exit when true' *\/$/;"	m	struct:expdesc
tailcalls	./src/lstate.h	/^  int tailcalls;  \/* number of tail calls lost under this entry *\/$/;"	m	struct:CallInfo
test2bits	./src/lgc.h	37;"	d
testAMode	./src/lopcodes.h	257;"	d
testTMode	./src/lopcodes.h	258;"	d
testbit	./src/lgc.h	34;"	d
testbits	./src/lgc.h	29;"	d
th	./src/lstate.h	/^  struct lua_State th;  \/* thread *\/$/;"	m	union:GCObject	typeref:struct:GCObject::lua_State
thvalue	./src/lobject.h	101;"	d
tmname	./src/lstate.h	/^  TString *tmname[TM_N];  \/* array with tag-method names *\/$/;"	m	struct:global_State
tmudata	./src/lstate.h	/^  GCObject *tmudata;  \/* last element of list of userdata to be GC *\/$/;"	m	struct:global_State
token	./src/llex.h	/^  int token;$/;"	m	struct:Token
tonumber	./src/lvm.h	18;"	d
top	./src/lstate.h	/^  StkId	top;  \/* top for this function *\/$/;"	m	struct:CallInfo
top	./src/lstate.h	/^  StkId top;  \/* first free slot in the stack *\/$/;"	m	struct:lua_State
tostring	./src/lvm.h	16;"	d
totalbytes	./src/lstate.h	/^  lu_mem totalbytes;  \/* number of bytes currently allocated *\/$/;"	m	struct:global_State
ts	./src/llex.h	/^  TString *ts;$/;"	m	union:__anon1
ts	./src/lstate.h	/^  union TString ts;$/;"	m	union:GCObject	typeref:union:GCObject::TString
tsv	./src/lobject.h	/^  } tsv;$/;"	m	union:TString	typeref:struct:TString::__anon6
tsvalue	./src/lobject.h	95;"	d
ttisboolean	./src/lobject.h	84;"	d
ttisfunction	./src/lobject.h	83;"	d
ttislightuserdata	./src/lobject.h	87;"	d
ttisnil	./src/lobject.h	79;"	d
ttisnumber	./src/lobject.h	80;"	d
ttisstring	./src/lobject.h	81;"	d
ttistable	./src/lobject.h	82;"	d
ttisthread	./src/lobject.h	86;"	d
ttisuserdata	./src/lobject.h	85;"	d
ttype	./src/lobject.h	90;"	d
tvk	./src/lobject.h	/^  TValue tvk;$/;"	m	union:TKey
twoto	./src/lobject.h	359;"	d
u	./src/lobject.h	/^  } u;$/;"	m	struct:UpVal	typeref:union:UpVal::__anon8
u	./src/lparser.h	/^  } u;$/;"	m	struct:expdesc	typeref:union:expdesc::__anon3
u	./src/lstate.h	/^  union Udata u;$/;"	m	union:GCObject	typeref:union:GCObject::Udata
ud	./src/lstate.h	/^  void *ud;         \/* auxiliary data to `frealloc' *\/$/;"	m	struct:global_State
upvaldesc	./src/lparser.h	/^typedef struct upvaldesc {$/;"	s
upvaldesc	./src/lparser.h	/^} upvaldesc;$/;"	t	typeref:struct:upvaldesc
upvals	./src/lobject.h	/^  UpVal *upvals[1];$/;"	m	struct:LClosure
upvalue	./src/lobject.h	/^  TValue upvalue[1];$/;"	m	struct:CClosure
upvalues	./src/lobject.h	/^  TString **upvalues;  \/* upvalue names *\/$/;"	m	struct:Proto
upvalues	./src/lparser.h	/^  upvaldesc upvalues[LUAI_MAXUPVALUES];  \/* upvalues *\/$/;"	m	struct:FuncState
uv	./src/lobject.h	/^  } uv;$/;"	m	union:Udata	typeref:struct:Udata::__anon7
uv	./src/lstate.h	/^  struct UpVal uv;$/;"	m	union:GCObject	typeref:struct:GCObject::UpVal
uvalue	./src/lobject.h	97;"	d
uvhead	./src/lstate.h	/^  UpVal uvhead;  \/* head of double-linked list of all open upvalues *\/$/;"	m	struct:global_State
v	./src/lobject.h	/^  TValue *v;  \/* points to stack or to its own value *\/$/;"	m	struct:UpVal
valiswhite	./src/lgc.h	75;"	d
value	./src/lobject.h	/^    TValue value;  \/* the value (when closed) *\/$/;"	m	union:UpVal::__anon8
varname	./src/lobject.h	/^  TString *varname;$/;"	m	struct:LocVar
weak	./src/lstate.h	/^  GCObject *weak;  \/* list of weak tables (to be cleared) *\/$/;"	m	struct:global_State
what	./src/lua.h	/^  const char *what;	\/* (S) `Lua', `C', `main', `tail' *\/$/;"	m	struct:lua_Debug
z	./src/llex.h	/^  ZIO *z;  \/* input stream *\/$/;"	m	struct:LexState
zgetc	./src/lzio.h	22;"	d
